// a / b, rounding up.
uint div_up(uint a, uint b) {return (a+b-1)/b}
uint round_mul_up(uint a, uint b) {return div_up(a,b) * b;}


kernel void vecinit(global float * out, int n)
{
  const int i = get_global_id(0);
  if (i<n) out[i] = (i+1);
}

int scan_pass(int gi, int nels, global int * restrict out, global const int * restrict in, local int * restrict lmem)
{

}

/*Single work group version: used to scan the tails of the partial scans*/
kernel void scan1(global int * restrict out, global const int * restrict in, local int* restrict lmem, uint nels)
{
  const uint gws = get_global_size(0);
  const uint lws = get_local_size(0);
  const uint li = get_local_id(0);
  uint gi = get_global_id(0);
  int corr = 0;

  uint limit = ((nels+lws-1)/lws)*lws;

  // while (gi < nels) // questo ciclo Ã¨ sbagliato, nel momento in cui il mio wg si trova a fare l'ultimo pezzo dei work item non finiranno.
  while (gi < limit) 
  {
    int acc = (gi < nels ? in[gi] : 0);  // starting data is stored in the registers
    
    uint write_mask = ~1U;
    uint read_mask = ~0U;

    lmem[li] = acc;      //Data now in local memory, the others can read the contents. One element per work-item
    while(write_mask < lws) // "srotolare sempre il while una/due volte"
    {
      barrier(CLK_LOCAL_MEM_FENCE);
      if (li & write_mask)
      {
        acc+= lmem[(li & read_mask) -1];
        lmem[li] = acc;
      }
      write_mask <<= 1;
      read_mask <<= 1;
    }
    acc+=corr;
    if (gi < nels) out[gi] = acc;

    barrier(CLK_LOCAL_MEM_FENCE);
    corr+=lmem[lws-1];
    gi+= get_local_size(0);

    // ensure that lmem[i] on the next cycle from the last work-item
    // doesn't overwrite lmem[lws-1] before all other work-items have read it.
    barrier(CLK_LOCAL_MEM_FENCE);
  }
}


// Multi workgroup version
kernel void scanN(global int * restrict out, global int * restrict tails, global const int * restrict in, 
  local int * restrict lmem, uint global_nels)
{
  const uint num_groups = get_num_groups(0)
  //const uint local_nels = global_nels / get_num_groups(0); // Rounding down
  const uint local_nels = div_up(global_nels, get_num_groups(0));  // Rounding up, nels for a single wg
  local_nels = round_mul_up(nels,lws) //Round up to the next multiple of lws
  
  const uint gws = get_global_size(0);
  const uint lws = get_local_size(0);
  const uint li = get_local_id(0);
  
  const uint begin = get_group_id(0) * local_nels;    // Bad starting value, not aligned
  const uint end = min(begin+local_nels, global_nels);  // Must not go over global_nels.
  const uint limit = round_mul_up(end, lws);

  int corr = 0;

  uint gi = begin + get_global_id(0);

  while(gi<limit)
  {
    corr = scan_pass(gi, nels, out, in, lmem, corr);
    gi+=lws;
  }
  if(get_local_id(0)==0)
    tails[get_group_id(0)] = corr;

}

/* Fixup the partial scans with the scanned tails */
kernel void scanN_fixup(global int * restrict out, global const int * restrict tails, uint global_nels)
{
  if (get_group_id(0) == 0) return;
}